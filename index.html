<!doctype html>
<html lang="es">

<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./logo_myl.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-title" content="Ventas M&L" />
    <title>Gestión de Ventas</title>

    <script type="module" crossorigin src="./index-NVVWiGcP.js"></script>
    <link rel="stylesheet" href="./index-cqvvk0bb.css?v=final">
    <link rel="manifest" href="./manifest.webmanifest">

    <style>
        /* --- ESTILOS QUIRÚRGICOS --- */

        /* 1. Contador de pedidos (Limpio y profesional) */
        /* 1. Contador de pedidos (ELIMINADO POR PETICION) */

        /* 2. Arreglo Símbolo Euro en Menú */
        .euro-menu-fix {
            font-size: 24px !important;
            display: inline-block;
            line-height: 1;
            transform: translateY(1px);
        }

        /* 3. Textos Ventas (Anteriormente Anual) */
        .texto-ventas {
            text-transform: uppercase !important;
            font-weight: 700 !important;
            color: #ffffff !important;
        }

        /* 4. Fechas (Ficha Cliente) */
        .fecha-espanol {
            font-size: 11px !important;
            font-weight: 700 !important;
            color: #94a3b8 !important;
            margin-bottom: 2px !important;
            display: block !important;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script>
        // ==========================================
        // ==========================================
        // 1. CÁLCULO DE PEDIDOS (ELIMINADO)
        // ==========================================
        function contarPedidos() {
            // Función eliminada para limpiar la UI
            return {};
        }

        // ==========================================
        // 2. EL ARREGLADOR VISUAL (Intervalo)
        // ==========================================
        setInterval(() => {

            // --- A. MENÚ INFERIOR (ESTRATEGIA SEGURA) ---
            // 1. Buscamos el texto "Dash"
            const dashSpans = Array.from(document.querySelectorAll('span, p, div')).filter(e => e.textContent.trim() === 'Dash');
            let barraMenu = null;

            // 2. Identificamos cuál es el del menú de abajo (por posición)
            for (const span of dashSpans) {
                const rect = span.getBoundingClientRect();
                // Si está en los últimos 100px de la pantalla, ES EL MENÚ
                if (rect.top > window.innerHeight - 100) {
                    // Buscamos el contenedor padre (la barra entera)
                    // Subimos 2 o 3 niveles hasta encontrar el contenedor flex
                    let candidato = span.parentElement;
                    for (let k = 0; k < 3; k++) {
                        if (candidato && candidato.parentElement) {
                            // Si el padre tiene varios hijos (botones), es la barra
                            if (candidato.parentElement.children.length > 4) {
                                barraMenu = candidato.parentElement;
                                break;
                            }
                        }
                        candidato = candidato ? candidato.parentElement : null;
                    }
                }
                if (barraMenu) break;
            }

            // 3. Si encontramos la barra, aplicamos estilos SOLO A SUS HIJOS
            if (barraMenu) {
                Array.from(barraMenu.children).forEach(boton => {
                    // Limpieza base
                    boton.style.backgroundColor = 'transparent';
                    boton.style.boxShadow = 'none';
                    boton.style.border = 'none';

                    // Color blanco a textos e iconos
                    const hijos = boton.querySelectorAll('*');
                    hijos.forEach(hijo => {
                        // Texto blanco
                        if (hijo.tagName !== 'SVG' && hijo.tagName !== 'IMG') {
                            hijo.style.color = '#ffffff';
                        }
                        // Arreglo especial Euro
                        if (hijo.textContent.includes('€') && !hijo.classList.contains('euro-menu-fix')) {
                            hijo.classList.add('euro-menu-fix');
                        }
                    });

                    // Iconos SVG -> Blanco
                    const iconos = boton.querySelectorAll('svg, img');
                    iconos.forEach(ico => ico.style.filter = 'brightness(0) invert(1)');

                    // Borde activo (si tiene fondo azul o clase active)
                    const estilo = window.getComputedStyle(boton);
                    if (boton.className.includes('active') || estilo.backgroundColor.includes('235') || location.href.includes(boton.textContent.trim().toLowerCase())) {
                        boton.style.borderBottom = '3px solid white';
                        boton.style.paddingBottom = '4px';
                    } else {
                        boton.style.borderBottom = 'none';
                    }
                });
            }

            // --- B. CONTADORES DE PEDIDOS (ELIMINADO) ---
            // Se ha eliminado la lógica de inyección de contadores por petición del usuario.
            const contadores = {}; // Placeholder vacío

            // --- C. TEXTOS GENERALES ---
            document.querySelectorAll('*').forEach(el => {
                if (el.children.length === 0 && el.textContent.trim()) {
                    const t = el.textContent.trim().toUpperCase();
                    // Reemplazo de ANUAL/HISTÓRICO por VENTAS
                    if (t.includes("ANUAL") || t.includes("HISTÓRICO") || t.includes("HISTORICO")) {
                        // Evitar bucles infinitos si ya se cambió
                        if (!el.dataset.replaced) {
                            el.textContent = el.textContent.replace(/ANUAL/gi, 'VENTAS').replace(/HISTÓRICO/gi, 'VENTAS').replace(/HISTORICO/gi, 'VENTAS');
                            el.classList.add('texto-ventas');
                            el.dataset.replaced = "true";
                        }
                    }
                    if (t === "MEDIA MENSUAL GLOBAL") {
                        el.textContent = "MEDIA ANUAL";
                    }
                    if (t === "HISTÓRICO VENTAS" || el.textContent.trim().toUpperCase() === "HISTÓRICO VENTAS") {
                        el.textContent = "Medias mensuales";
                    }
                    // Nuevo: Forzar blanco en cabeceras clave
                    if (t === "TOTALES" || t === "ULTIMA" || t === "ANUAL") {
                        el.style.color = '#ffffff';
                    }
                }
            });

            // --- D. TOP CLIENTES (CIFRAS MÁS GRANDES) ---
            document.querySelectorAll('*').forEach(el => {
                if (el.children.length === 0 && el.textContent.includes(' €') && !el.classList.contains('euro-menu-fix')) {
                    // Si el tamaño es pequeño (ej. 0.75rem o 12px), lo subimos un poco
                    const s = window.getComputedStyle(el);
                    const size = parseFloat(s.fontSize);
                    if (size < 13) {
                        el.style.fontSize = '13px';
                        el.style.fontWeight = '600';
                        el.style.opacity = '0.9';
                    }
                }
            });

            // --- E. FECHAS (FORMATO Y TAMAÑO) ---
            document.querySelectorAll('*').forEach(el => {
                if (el.children.length === 0) {
                    const t = el.textContent.trim();
                    if (/^\d{4}-\d{2}-\d{2}$/.test(t)) {
                        const [y, m, d] = t.split('-');
                        el.textContent = `${d}-${m}-${y}`;
                        el.classList.add('fecha-espanol');
                    }
                }
            });

            // --- F. CABECERA SUPERIOR (GENERICA - TODAS LAS VENTANAS) ---
            // Detectar textos en la barra superior (Top < 65px) y forzarlos a blanco
            document.querySelectorAll('div, span, h1, h2, h3, h4, h5, h6, a, p').forEach(el => {
                // Solo elementos hoja (sin hijos) con texto
                if (el.children.length === 0 && el.textContent.trim().length > 0) {
                    const rect = el.getBoundingClientRect();
                    // Si está en la zona visual del header (aprox 65px alto)
                    if (rect.top >= 0 && rect.bottom <= 65) {
                        // Verificar que no sea transparente (oculto)
                        if (rect.width > 0 && rect.height > 0) {
                            // Forzar blanco (con !important para vencer framework CSS)
                            el.style.setProperty('color', '#ffffff', 'important');
                        }
                    }
                }
            });

            // --- G. ORDENAR PEDIDOS VISUALMENTE (Fecha DESC, luego Nº DESC) ---
            try {
                const headers = Array.from(document.querySelectorAll('div, th, span')).filter(x =>
                    x.textContent.trim() === 'TIENDA' || x.textContent.trim() === 'IMPORTE'
                );

                if (headers.length > 0) {
                    let headerEl = headers[0];
                    let headerRow = headerEl.parentElement;
                    while (headerRow && headerRow.parentElement && headerRow.children.length < 2) {
                        headerRow = headerRow.parentElement;
                    }

                    if (headerRow && headerRow.parentElement) {
                        const container = headerRow.parentElement;
                        let rows = Array.from(container.children).filter(child =>
                            child !== headerRow &&
                            child.textContent.trim() !== '' &&
                            (child.textContent.includes('€') || child.textContent.includes('/')) &&
                            /\d/.test(child.textContent) // Debe tener números
                        );

                        if (rows.length > 1) {
                            // Helper: Parsear Fecha (dd/mm/yy) -> Timestamp
                            const getDateScore = (row) => {
                                const text = row.textContent;
                                const match = text.match(/(\d{2})\/(\d{2})\/(\d{2})/);
                                if (match) {
                                    const d = parseInt(match[1]);
                                    const m = parseInt(match[2]);
                                    const y = 2000 + parseInt(match[3]);
                                    return (y * 10000) + (m * 100) + d; // YYYYMMDD
                                }
                                return 0;
                            };

                            // Helper: Parsear ID (Inicio de línea)
                            const getId = (row) => {
                                const match = row.textContent.trim().match(/^(\d+)/);
                                return match ? parseInt(match[1]) : 0;
                            };

                            let needsSort = false;
                            for (let i = 0; i < rows.length - 1; i++) {
                                const scoreA = getDateScore(rows[i]);
                                const scoreB = getDateScore(rows[i + 1]);

                                if (scoreA < scoreB) { needsSort = true; break; }
                                if (scoreA === scoreB) {
                                    const idA = getId(rows[i]);
                                    const idB = getId(rows[i + 1]);
                                    if (idA < idB) { needsSort = true; break; }
                                }
                            }

                            if (needsSort) {
                                rows.sort((a, b) => {
                                    const dateDiff = getDateScore(b) - getDateScore(a);
                                    if (dateDiff !== 0) return dateDiff;
                                    return getId(b) - getId(a);
                                });

                                let currentAnchor = headerRow;
                                rows.forEach(row => {
                                    currentAnchor.after(row);
                                    currentAnchor = row;
                                });
                            }
                        }
                    }
                }
            } catch (e) { }

        }, 500);
    </script>
</body>

</html>